---
AWSTemplateFormatVersion: "2010-09-09"

Description: |-
  Experimental AWS Step Function to stop RDS and Aurora databases after the
  forced 7th-day start.

  github.com/sqlxpert/step-stay-stopped-aws-rds-aurora GPLv3 Copyright Paul
  Marcelin

Parameters:

  PlaceholderSuggestedStackName:
    Type: String
    Default: "StepStayStoppedRdsAurora"

  PlaceholderHelp:
    Type: String
    Default: "github.com/sqlxpert/step-stay-stopped-aws-rds-aurora"

  Enable:
    Type: String
    Description: >-
      Whether to stop databases forcibly started after 7 days
    # Default: "true"
    Default: "false"  # TODO
    AllowedValues:
      - "false"
      - "true"

  FollowUntilStopped:
    Type: String
    Description: >-
      Whether to monitor after requesting that a database be stopped. The
      default, "true", provides an ERROR-level log entry or an error (dead
      letter) queue message if the stop request is not complete
      StepFnTimeoutSecs * StepFnWaitSecs (defaults of 160
      times and 540 seconds or 9 minutes give 24 hours) after AWS started the
      database. If someone starts the database manually after it enters
      "stopped" status but before the next and final retry, the database will
      be stopped another time. This window lasts StepFnWaitSecs
      (540 seconds or 9 minutes, by default) and occurs every 7th day, but at
      an unpredictable time of day. Changing the value to "false" eliminates
      the conflict window, at the expense of the completion monitoring.
    Default: "true"
    AllowedValues:
      - "false"
      - "true"

  PlaceholderAdvancedParameters:
    Type: String
    Default: ""
    AllowedValues:
      - ""

  Test:
    Type: String
    Description: >-
      Whether to add Aurora database cluster and RDS database instance
      non-forced start events for temporary testing, and relax the queue
      policy for the main SQS queue so that users can send, read, and delete
      messages, for example, using the AWS Console or the AWS ClI.
      Tip:
      Temporarily reducing StepFnWaitSecs and
      StepFnTimeoutSecs , and changing LogLevel to "INFO", also facilitates
      testing.
      WARNING:
      Setting this to "true" causes any Aurora database cluster or RDS
      database instance to be stopped as soon as it is started.
    # Default: "false"
    Default: "true"  # TODO
    AllowedValues:
      - "false"
      - "true"

  ErrorQueueMessageRetentionPeriodSecs:
    Type: Number
    Description: >-
      How many seconds to keep error queue messages. For consistency, set this
      to LogRetentionInDays * 86400 or the next largest value allowed by both
      CloudWatch Logs and Simple Queue Service. The default, 1209600 , is 14
      days. See MessageRetentionPeriod in
      https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SetQueueAttributes.html#API_SetQueueAttributes_RequestParameters
    Default: 1209600

  ErrorQueueMessageBytesMax:
    Type: Number
    Description: >-
      The maximum number of bytes in a forced database start event and an AWS
      Step Function trigger event. The default, 32768 bytes, is 32 KiB. See
      MaximumMessageSize in
      https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_CreateQueue.html#API_CreateQueue_RequestParameters
    Default: 32768

  SqsKmsKey:
    Type: String
    Description: >-
      If this is blank, default non-KMS SQS encryption applies. To use the
      AWS-managed key (which does not support key policy restrictions, or
      cross-region or cross-account usage), specify "alias/aws/sqs". To use a
      custom key, specify "ACCOUNT:key/KEY_ID". Whether the custom key is a
      single-region key, a multi-region key primary, or a multi-region key
      replica, it must be in the same region where you are creating this
      stack. Even if the custom key is in the same AWS account as this stack,
      you must update the key policy to allow usage by EventBridge and SQS.
      See
      https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html#targets-permissions
      and
      https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-key-management.html#compatibility-with-aws-services
      . For a StackSet, if you wish to use a custom key, it must be
      multi-region ("mrk-" prefix in the KEY_ID), and a replica (or the
      primary key itself) must exist in every target region.
    Default: ""

  StepFnRoleAttachLocalPolicyName:
    Type: String
    Description: >-
      The name of a customer-managed IAM policy to attach to the Step Function
      role. By including "Effect": "Deny" statements, you could, for example,
      prevent the function from ever stopping production databases.
      Specify only the name, not the ARN.
      For a StackSet, the policy must exist, and have exactly the same name,
      in every target AWS account.
      Policies are account-wide, not regional.
    Default: ""

  StepFnTaskTimeoutSecs:
    Type: Number
    Description: >-
      How many seconds to wait for an AWS request, such as a StopDBCluster
      request, to return (not to complete). The default is 30 seconds. Increase
      this only in case of time-out errors.
    Default: 30

  StepFnWaitSecs:
    Type: Number
    Description: >-
      How many seconds between attempts to stop a database. The default, 540
      seconds or 9 minutes, allows a second stop attempt as late as possible
      within the 10-minute minimum billing period after a database starts.
      Reduce for for testing.
    Default: 540

  StepFnTimeoutSecs:
    Type: Number
    Description: >-
      For how many seconds to keep trying to stop a database. The default,
      86400 , is 24 hours.
      Reduce for for testing.
    Default: 86400

  LogRetentionInDays:
    Type: Number
    Description: >-
      How many days to keep log entries. Because AWS starts stopped RDS and
      Aurora databases after 7 days, set this to the next largest allowed
      value to preserve information about the previous round of database
      start events. See retentionInDays in
      https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html#API_PutRetentionPolicy_RequestParameters
    Default: 14

  LogLevel:
    Type: String
    Description: >-
      The level of detail in the log. See
      https://docs.aws.amazon.com/step-functions/latest/dg/cw-logs.html#cloudwatch-log-level
    # Default: ERROR
    Default: ALL  # TODO
    AllowedValues:
      - ALL
      - ERROR
      - FATAL
      - "OFF"

  CloudWatchLogsKmsKey:
    Type: String
    Description: >-
      If this is blank, default non-KMS CloudWatch Logs encryption applies. To
      use a KMS key, which must be a custom key, specify "ACCOUNT:key/KEY_ID".
      Whether the custom key is a single-region key, a multi-region key
      primary, or a multi-region key replica, it must be in the same region
      where you are creating this stack. Even if the custom key is in the same
      AWS account as this stack, you must update the key policy to allow usage
      by CloudWatch Logs. See
      https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/encrypt-log-data-kms.html#cmk-permissions
      . For a StackSet, the custom key must be multi-region ("mrk-" prefix in
      the KEY_ID), and a replica (or the primary key itself) must exist in
      every target region.
    Default: ""

Metadata:

  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: For Reference
        Parameters:
          - PlaceholderSuggestedStackName
          - PlaceholderHelp
      - Label:
          default: Essential
        Parameters:
          - Enable
          - FollowUntilStopped
      - Label:
          default: Advanced...
        Parameters:
          - PlaceholderAdvancedParameters
      - Label:
          default: Testing
        Parameters:
          - Test
      - Label:
          default: SQS queue for errors
        Parameters:
          - ErrorQueueMessageRetentionPeriodSecs
          - ErrorQueueMessageBytesMax
          - SqsKmsKey
      - Label:
          default: AWS Step Function to stop databases
        Parameters:
          - StepFnRoleAttachLocalPolicyName
          - StepFnTaskTimeoutSecs
          - StepFnWaitSecs
          - StepFnTimeoutSecs
      - Label:
          default: CloudWatch log for AWS Step Function
        Parameters:
          - LogRetentionInDays
          - LogLevel
          - CloudWatchLogsKmsKey
    ParameterLabels:
      PlaceholderHelp:
        default: For help with this stack, see
      PlaceholderSuggestedStackName:
        default: Suggested stack name
      Enable:
        default: Enable?
      FollowUntilStopped:
        default: Follow the database after a stop request?
      PlaceholderAdvancedParameters:
        default: Do not change the parameters below, unless necessary!
      Test:
        default: Test mode?
      ErrorQueueMessageRetentionPeriodSecs:
        default: Seconds before deleting a message
      ErrorQueueMessageBytesMax:
        default: Maximum bytes in a message
      SqsKmsKey:
        default: KMS encryption key
      StepFnRoleAttachLocalPolicyName:
        default: Name of local IAM policy to attach to role
      StepFnTaskTimeoutSecs:
        default: Maximum seconds for an AWS request
      StepFnWaitSecs:
        default: Seconds between attempts to stop a database
      StepFnTimeoutSecs:
        default: Maximum seconds to try stopping a database
      LogRetentionInDays:
        default: Days before deleting
      LogLevel:
        default: Level of detail
      CloudWatchLogsKmsKey:
        default: KMS encryption key

Conditions:

  EnableTrue: !Equals [ !Ref Enable, "true" ]

  FollowUntilStoppedTrue: !Equals [ !Ref FollowUntilStopped, "true" ]

  TestTrue: !Equals [ !Ref Test, "true" ]

  SqsKmsKeyBlank: !Equals [ !Ref SqsKmsKey, "" ]
  SqsKmsKeyCustom:
    Fn::And:
      - !Not [ !Condition SqsKmsKeyBlank ]
      - !Not [ !Equals [ !Ref SqsKmsKey, "alias/aws/sqs" ] ]

  StepFnRoleAttachLocalPolicyNameBlank:
    !Equals [ !Ref StepFnRoleAttachLocalPolicyName, "" ]

  CloudWatchLogsKmsKeyBlank: !Equals [ !Ref CloudWatchLogsKmsKey, "" ]

Resources:


  # Administrator: Block other AWS Step Function execution mechanisms.
  ExecuteStepFnRole:
    Type: AWS::IAM::Role
    Properties:
      Description: !Sub "For ${AWS::Region} region"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: events.amazonaws.com }
            Action: sts:AssumeRole
      Policies:

        - PolicyName: StepFnExecute
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: states:StartExecution
                Resource: !GetAtt StepFn.Arn

        - Fn::If:
            - SqsKmsKeyCustom
            - PolicyName: SqsKmsEncryptNoteComplementsQueuePolicy
              PolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: Allow
                    Action:
                      # https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-key-management.html#send-to-encrypted-queue
                      - kms:GenerateDataKey
                      - kms:Decrypt  # To verify a new data key!
                    Resource: !Sub "arn:${AWS::Partition}:kms:${AWS::Region}:${SqsKmsKey}"
                    Condition:
                      StringEquals: { "kms:ViaService": !Sub "sqs.${AWS::Region}.amazonaws.com" }
            - !Ref AWS::NoValue

  # Administrator: Restrict iam:PassRole to prevent use with arbitrary AWS
  # Step Functions.
  StepFnRole:
    Type: AWS::IAM::Role
    Properties:
      Description: !Sub "For ${AWS::Region} region"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: !Sub "states.${AWS::Region}.amazonaws.com" }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - Fn::If:
            - StepFnRoleAttachLocalPolicyNameBlank
            - !Ref AWS::NoValue
            - !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/${StepFnRoleAttachLocalPolicyName}"
      Policies:

        # In-line policies apply only to one role, which can only be assumed
        # by AWS Step Functions. Separate, "managed" policies could be
        # attached to other roles or users, allowing permission escalation.

        # https://docs.aws.amazon.com/step-functions/latest/dg/cw-logs.html#cloudwatch-iam-policy
        # https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AWS-logs-and-resource-policy.html#AWS-logs-infrastructure-CWL
        - PolicyName: CloudWatchLogsRead
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:DescribeResourcePolicies
                  - logs:DescribeLogGroups
                  - logs:ListLogDeliveries
                  - logs:GetLogDelivery
                Resource: "*"
        - PolicyName: CloudWatchLogsInitialize
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:PutResourcePolicy
                  - logs:CreateLogDelivery
                  - logs:UpdateLogDelivery
                  - logs:DeleteLogDelivery
                Resource: "*"

        - PolicyName: CloudWatchLogsCreateLogGroupIfDeleted
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                Resource: !GetAtt StepFnLogGrp.Arn

        - PolicyName: CloudWatchLogsWrite
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${StepFnLogGrp}:log-stream:*"
                # !GetAtt LogGroup.Arn ends with :* instead of allowing us to
                # append :log-stream:* to make a log stream ARN

        - PolicyName: RdsRead
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - rds:DescribeDBInstances
                  - rds:DescribeDBClusters
                Resource: "*"
              - Effect: Allow
                Action: rds:ListTagsForResource
                Resource:
                  - !Sub "arn:${AWS::Partition}:rds:${AWS::Region}:${AWS::AccountId}:db:*"
                  - !Sub "arn:${AWS::Partition}:rds:${AWS::Region}:${AWS::AccountId}:cluster:*"

        - PolicyName: RdsWrite
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - rds:StopDBInstance
                  - rds:StopDBCluster
                Resource:
                  - !Sub "arn:${AWS::Partition}:rds:${AWS::Region}:${AWS::AccountId}:db:*"
                  - !Sub "arn:${AWS::Partition}:rds:${AWS::Region}:${AWS::AccountId}:cluster:*"

        # - Fn::If:
        #     - SqsKmsKeyCustom
        #     - PolicyName: SqsKmsDecryptNoteComplementsQueuePolicy
        #       PolicyDocument:
        #         Version: "2012-10-17"
        #         Statement:
        #           - Effect: Allow
        #             Action:
        #               # https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-key-management.html#receive-from-encrypted-queue
        #               - kms:Decrypt
        #             Resource: !Sub "arn:${AWS::Partition}:kms:${AWS::Region}:${SqsKmsKey}"
        #             Condition:
        #               StringEquals: { "kms:ViaService": !Sub "sqs.${AWS::Region}.amazonaws.com" }
        #     - !Ref AWS::NoValue

  ErrorQueuePol:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues: [ !Ref ErrorQueue ]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: RequireTls
            Effect: Deny
            Principal: "*"
            Action: sqs:*
            Resource: "*"
            Condition:
              Bool: { aws:SecureTransport: "false" }
          - Effect: Allow
            Principal: "*"
            Action: sqs:GetQueueAttributes
            Resource: "*"
          - Sid:
              Fn::If:
                - SqsKmsKeyCustom
                - SourceEventRulesNoteKeyPolicyNeedsEventBridgeSqsKmsEncrypt
                - SourceEventRules
            Effect: Allow
            Principal: { Service: events.amazonaws.com }
            Action: sqs:SendMessage
            Resource: "*"
            Condition:
              ArnEquals:
                "aws:SourceArn":
                  - !GetAtt AuroraDbForcedStartToStepFnRule.Arn
                  - !GetAtt RdsDbForcedStartToStepFnRule.Arn
          - Sid: ExclusiveSources
            Effect: Deny
            Principal: "*"
            Action: sqs:SendMessage
            Resource: "*"
            Condition:
              ArnNotEquals:
                "aws:SourceArn":
                  - !GetAtt AuroraDbForcedStartToStepFnRule.Arn
                  - !GetAtt RdsDbForcedStartToStepFnRule.Arn

  AuroraDbForcedStartToStepFnRule:
    Type: AWS::Events::Rule
    Properties:
      Description:
        Fn::If:
          - TestTrue
          - !Sub >-
              RDS-EVENT-0153 forced Aurora database cluster start after 7 days,
              plus RDS-EVENT-0151 non-forced start for TEMPORARY TESTING,
              to ${StepFn.Name}
          - !Sub >-
              RDS-EVENT-0153 forced Aurora database cluster start after 7 days,
              to ${StepFn.Name}
      EventPattern:
        source: [ aws.rds ]
        detail-type: [ RDS DB Cluster Event ]
        detail:
          EventID:

            - RDS-EVENT-0153
            # https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html#RDS-EVENT-0153
            # "DB cluster is being started due to it exceeding the maximum
            # allowed time being stopped."

            - !If [ TestTrue, RDS-EVENT-0151, !Ref AWS::NoValue ]
            # https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html#RDS-EVENT-0151
            # "DB cluster started."

          SourceType: [ CLUSTER ]
          SourceIdentifier:
            - anything-but:
                - ""
                # https://github.com/aws-cloudformation/cloudformation-coverage-roadmap/issues/1378
                # - null
        version: [ "0" ]
      Targets:
        - Id: !GetAtt StepFn.Name
          RoleArn: !GetAtt ExecuteStepFnRole.Arn
          Arn: !GetAtt StepFn.Arn
          RetryPolicy:
            MaximumRetryAttempts: 10
            MaximumEventAgeInSeconds: 300  # 5 minutes
          DeadLetterConfig: { Arn: !GetAtt ErrorQueue.Arn }
      State: !If [ EnableTrue, ENABLED, DISABLED ]

  RdsDbForcedStartToStepFnRule:
    Type: AWS::Events::Rule
    Properties:
      Description:
        Fn::If:
          - TestTrue
          - !Sub >-
              RDS-EVENT-0154 forced RDS database instance start after 7 days,
              plus RDS-EVENT-0088 non-forced start (ignored for instances in
              Aurora clusters) for TEMPORARY TESTING,
              to ${StepFn.Name}
          - !Sub >-
              RDS-EVENT-0154 forced RDS database instance start after 7 days,
              to ${StepFn.Name}
      EventPattern:
        source: [ aws.rds ]
        detail-type: [ RDS DB Instance Event ]
        detail:
          EventID:

            - RDS-EVENT-0154
            # https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html#RDS-EVENT-0154
            # "DB instance is being started due to it exceeding the maximum
            # allowed time being stopped."

            - !If [ TestTrue, RDS-EVENT-0088, !Ref AWS::NoValue ]
            # https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_Events.Messages.html#RDS-EVENT-0088
            # "DB instance started."
            #
            # Warning: Aurora database instances have an event that is
            # indistinguishable at this level. The AWS Step Function ignores
            # it.
            # https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/USER_Events.Messages.html#RDS-EVENT-0088
            # "DB instance started."

          SourceType: [ DB_INSTANCE ]
          SourceIdentifier:
            - anything-but:
                - ""
                # https://github.com/aws-cloudformation/cloudformation-coverage-roadmap/issues/1378
                # - null
        version: [ "0" ]
      Targets:
        - Id: !GetAtt StepFn.Name
          RoleArn: !GetAtt ExecuteStepFnRole.Arn
          Arn: !GetAtt StepFn.Arn
          RetryPolicy:
            MaximumRetryAttempts: 10
            MaximumEventAgeInSeconds: 300  # 5 minutes
          DeadLetterConfig: { Arn: !GetAtt ErrorQueue.Arn }
      State: !If [ EnableTrue, ENABLED, DISABLED ]

  ErrorQueue:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      SqsManagedSseEnabled: !If [ SqsKmsKeyBlank, true, false ]
      KmsMasterKeyId:
        Fn::If:
          - SqsKmsKeyBlank
          - !Ref AWS::NoValue
          - Fn::If:
              - SqsKmsKeyCustom
              - !Sub "arn:${AWS::Partition}:kms:${AWS::Region}:${SqsKmsKey}"
              - !Ref SqsKmsKey
      KmsDataKeyReusePeriodSeconds:
        !If [ SqsKmsKeyBlank, !Ref AWS::NoValue, 86400 ]  # seconds (24 hours)
      MaximumMessageSize: !Ref ErrorQueueMessageBytesMax
      MessageRetentionPeriod: !Ref ErrorQueueMessageRetentionPeriodSecs
      ReceiveMessageWaitTimeSeconds: 20  # long polling (lowest cost)
      VisibilityTimeout: 0  # seconds; dead message retries don't make sense

  # StepFnLogGrpPol:
  #   Type: AWS::Logs::ResourcePolicy
  #   Properties:
  #     PolicyName: test
  #     PolicyDocument: !Sub |
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Principal: { Service: delivery.logs.amazonaws.com }
  #           Action:
  #             - logs:CreateLogStream
  #             - logs:PutLogEvents
  #           Resource:
  #             - "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:${StepFnLogGrp}:log-stream:*"
  #           Condition:
  #             StringEquals:
  #               "aws:SourceAccount":
  #                 - "${AWS::AccountId}"
  #             ArnLike:
  #               "aws:SourceArn":
  #                 - "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
    # ${LogGroup.Arn} ends with :* instead of allowing us to
    # append :log-stream:* to make a log stream ARN

  StepFnLogGrp:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref LogRetentionInDays
      KmsKeyId:
        Fn::If:
          - CloudWatchLogsKmsKeyBlank
          - !Ref AWS::NoValue
          - !Sub "arn:${AWS::Partition}:kms:${AWS::Region}:${CloudWatchLogsKmsKey}"

  StepFn:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      # DefinitionSubstitutions:
      #   Key: Value
      # EncryptionConfiguration:
      #   Type: CUSTOMER_MANAGED_KMS_KEY | AWS_OWNED_KEY
      #   KmsKeyId: String
      #   KmsDataKeyReusePeriodSeconds: 900
      LoggingConfiguration:
        IncludeExecutionData: true
        Level: !Ref LogLevel
        Destinations:
          - CloudWatchLogsLogGroup: { LogGroupArn: !GetAtt StepFnLogGrp.Arn }
      TracingConfiguration: { Enabled: false }
      RoleArn: !GetAtt StepFnRole.Arn
      StateMachineType: STANDARD
      DefinitionString: !Sub |-
        {
          "Comment": "Stop AWS RDS and Aurora databases after the forced 7th-day start",
          "QueryLanguage": "JSONata",
          "StartAt": "AssignConstants",
          "States": {
            "AssignConstants": {
              "Type": "Pass",
              "Next": "ParseEvent",
              "Assign": {
                "TaskTimeoutSeconds": ${StepFnTaskTimeoutSecs},
                "WaitSeconds": ${StepFnWaitSecs}
              }
            },
            "ParseEvent": {
              "Type": "Pass",
              "Next": "Expired?",
              "Output": "{% {\n  'Date': $states.input.detail.Date,\n  'SourceIdentifier': $states.input.detail.SourceIdentifier,\n\n  /* Events have 'CLUSTER' (Aurora) or 'DB_INSTANCE' (RDS); take last word */\n  'SourceTypeWord': $split($states.input.detail.SourceType,'_')[-1]\n} %}"
            },
            "Expired?": {
              "Type": "Choice",
              "Default": "SourceTypeWord",
              "Choices": [
                {
                  "Next": "Fail",
                  "Condition": "{% $toMillis($states.input.Date) < ( $millis() - (24 * 60 * 60 * 1000) ) %}"
                }
              ]
            },
            "SourceTypeWord": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "StopDBCluster",
                  "Condition": "{% 'CLUSTER' = $states.input.SourceTypeWord %}"
                },
                {
                  "Next": "StopDBInstance",
                  "Condition": "{% 'INSTANCE' = $states.input.SourceTypeWord %}"
                }
              ]
            },
            "StopDBCluster": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:rds:stopDBCluster",
              "Next": "Wait",
              "Catch": [
                {
                  "ErrorEquals": [
                    "Rds.InvalidDbClusterStateException"
                  ],
                  "Next": "DbClusterStatusRegExpMatch",
                  "Assign": {
                    "DbClusterStatusRegExpMatch": "{% $match($states.errorOutput.Cause, /^DbCluster [^ ]+ is in (.+) state/, 1) %}"
                  },
                  "Output": "{% $states.input %}"
                },
                {
                  "ErrorEquals": [
                    "Rds.InvalidDbInstanceStateException"
                  ],
                  "Next": "Wait",
                  "Comment": "Until each cluster member becomes available",
                  "Output": "{% $states.input %}"
                },
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Wait",
                  "Output": "{% $states.input %}"
                }
              ],
              "Arguments": {
                "DbClusterIdentifier": "{% $states.input.SourceIdentifier %}"
              },
              "Output": "{% $states.input %}",
              "TimeoutSeconds": "{% $TaskTimeoutSeconds %}"
            },
            "DbClusterStatusRegExpMatch": {
              "Type": "Choice",
              "Default": "DbStatus",
              "Choices": [
                {
                  "Next": "Wait",
                  "Condition": "{% null = $DbClusterStatusRegExpMatch %}"
                }
              ],
              "Output": "{% $merge([$states.input, {'DbStatus': $lowercase($DbClusterStatusRegExpMatch.groups[0])}]) %}"
            },
            "StopDBInstance": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:rds:stopDBInstance",
              "Next": "Wait",
              "Catch": [
                {
                  "ErrorEquals": [
                    "Rds.InvalidDbInstanceStateException"
                  ],
                  "Next": "DescribeDBInstances",
                  "Output": "{% $states.input %}"
                },
                {
                  "ErrorEquals": [
                    "Rds.RdsException"
                  ],
                  "Next": "AuroraDbInstanceNotEligibleForStopping",
                  "Output": "{% $states.input %}",
                  "Assign": {
                    "AuroraDbInstanceNotEligibleForStopping": "{% $contains($states.errorOutput.Cause, 'aurora') and $contains($states.errorOutput.Cause, 'not eligible for stopping') %}"
                  },
                  "Comment": "InvalidParameterCombination. Occurs only in test mode. RDS-EVENT-0088 database instance non-forced start is indistinguishable for RDS (accepted) and Aurora (rejected in favor of RDS-EVENT-0151 database cluster non-forced start)."
                },
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Wait",
                  "Output": "{% $states.input %}"
                }
              ],
              "Arguments": {
                "DbInstanceIdentifier": "{% $states.input.SourceIdentifier %}"
              },
              "Output": "{% $states.input %}",
              "TimeoutSeconds": "{% $TaskTimeoutSeconds %}"
            },
            "AuroraDbInstanceNotEligibleForStopping": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Succeed",
                  "Condition": "{% $AuroraDbInstanceNotEligibleForStopping %}"
                }
              ],
              "Default": "Fail"
            },
            "DescribeDBInstances": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:rds:describeDBInstances",
              "Next": "DbStatus",
              "Arguments": {
                "DbInstanceIdentifier": "{% $states.input.SourceIdentifier %}"
              },
              "Output": "{% $merge([$states.input, {'DbStatus': $states.result.DbInstances[0].DbInstanceStatus}]) %}",
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Wait",
                  "Output": "{% $states.input %}"
                }
              ],
              "TimeoutSeconds": "{% $TaskTimeoutSeconds %}"
            },
            "DbStatus": {
              "Default": "Wait",
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Fail",
                  "Condition": "{% $states.input.DbStatus in ['inaccessible-encryption-credentials', 'cloning-failed', 'migration-failed', 'preparing-data-migration', 'failed', 'incompatible-restore', 'insufficient-capacity', 'restore-error', 'storage-full'] %}"
                },
                {
                  "Next": "Succeed",
                  "Condition": "{% $states.input.DbStatus in ['stopped', 'deleting', 'deleted'] %}"
                }
              ]
            },
            "Wait": {
              "Next": "SourceTypeWord",
              "Seconds": "{% $WaitSeconds %}",
              "Type": "Wait"
            },
            "Fail": {
              "Type": "Fail"
            },
            "Succeed": {
              "Type": "Succeed"
            }
          },
          "TimeoutSeconds": ${StepFnTimeoutSecs}
        }
