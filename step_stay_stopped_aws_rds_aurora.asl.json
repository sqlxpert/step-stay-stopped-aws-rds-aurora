{
  "Comment": "Stop AWS RDS and Aurora databases after the forced 7th-day start",
  "QueryLanguage": "JSONata",
  "TimeoutSeconds": ${StepFnTimeoutSeconds},
  "StartAt": "AssignConstantsAndExtractDbIdentifierFromEvent",
  "States": {
    "AssignConstantsAndExtractDbIdentifierFromEvent": {
      "Type": "Pass",
      "Assign": {
        "Constant": "{% {\n  'StepFnTaskTimeoutSeconds': ${StepFnTaskTimeoutSeconds},\n  'DoNotFollowUntilStopped': 'false' = '${FollowUntilStopped}' /* CloudFormation supplies a string! */,\n  'StepFnWaitSeconds': ${StepFnWaitSeconds},\n  'StepFnTimeoutMilliseconds': ${StepFnTimeoutSeconds} * 1000\n} %}"
      },
      "Comment": "Process JSON state machine definition with CloudFormation Fn::Sub to resolve constants",
      "Output": "{% {\n  'Event': $states.input,\n  'Date': $states.input.detail.Date,\n  'SourceIdentifier': $states.input.detail.SourceIdentifier,\n  'SourceTypeWord': $split($states.input.detail.SourceType,'_')[-1]\n  /* Last word of 'CLUSTER' (Aurora) or 'DB_INSTANCE' (RDS) */\n} %}",
      "Next": "IfEventNotExpiredChooseDbClusterOrInstance"
    },
    "IfEventNotExpiredChooseDbClusterOrInstance": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% $toMillis($states.input.Date) < ( $millis() - $Constant.StepFnTimeoutMilliseconds ) %}",
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'EventExpired'}\n]) %}",
          "Next": "Fail"
        },
        {
          "Condition": "{% 'CLUSTER' = $states.input.SourceTypeWord %}",
          "Output": "{% \n  $states.input ~> | $ | {}, ['Error', 'Cause'] |\n  /* Delete any past error; https://docs.jsonata.org/other-operators#-------transform */\n %}",
          "Next": "StopDBCluster"
        },
        {
          "Condition": "{% 'INSTANCE' = $states.input.SourceTypeWord %}",
          "Output": "{% \n  $states.input ~> | $ | {}, ['Error', 'Cause'] |\n  /* Delete any past error; https://docs.jsonata.org/other-operators#-------transform */\n %}",
          "Next": "StopDBInstance"
        }
      ]
    },
    "StopDBCluster": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:rds:stopDBCluster",
      "Arguments": {
        "DbClusterIdentifier": "{% $states.input.SourceIdentifier %}"
      },
      "TimeoutSeconds": "{% $Constant.StepFnTaskTimeoutSeconds %}",
      "Catch": [
        {
          "ErrorEquals": [
            "Rds.InvalidDbClusterStateException"
          ],
          "Output": "{% (\n  $DbClusterStatusRegExpMatch := $match($states.errorOutput.Cause, /^DbCluster [^ ]+ is in (.+) state/, 1);\n  $merge([\n    $states.input,\n    $DbClusterStatusRegExpMatch\n    ?\n    {'DbStatus': $lowercase($DbClusterStatusRegExpMatch.groups[0])}\n    :\n    {'DbStatus': '', 'Error': 'StopDBCluster|CannotParseException', 'Cause': $string($states.errorOutput.Cause)}\n  ])\n) %}",
          "Next": "DbStatus"
        },
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "Comment": "Includes Rds.InvalidDbInstanceStateException, which occurs until each cluster member becomes available",
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'StopDBCluster|' & $states.errorOutput.Error, 'Cause': $string($states.errorOutput.Cause)}\n]) %}",
          "Next": "Wait"
        }
      ],
      "Output": "{% $states.input %}",
      "Next": "FollowUntilStopped?"
    },
    "StopDBInstance": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:rds:stopDBInstance",
      "Arguments": {
        "DbInstanceIdentifier": "{% $states.input.SourceIdentifier %}"
      },
      "TimeoutSeconds": "{% $Constant.StepFnTaskTimeoutSeconds %}",
      "Catch": [
        {
          "ErrorEquals": [
            "Rds.InvalidDbInstanceStateException"
          ],
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'StopDBInstance|' & $states.errorOutput.Error, 'Cause': $string($states.errorOutput.Cause)}\n]) %}",
          "Next": "DescribeDBInstances"
        },
        {
          "ErrorEquals": [
            "Rds.RdsException"
          ],
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'StopDBInstance|' & $states.errorOutput.Error, 'Cause': $string($states.errorOutput.Cause)}\n]) %}",
          "Next": "AuroraDbInstanceNotEligibleForStopping?"
        },
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'StopDBInstance|' & $states.errorOutput.Error, 'Cause': $string($states.errorOutput.Cause)}\n]) %}",
          "Next": "Wait"
        }
      ],
      "Output": "{% $states.input %}",
      "Next": "FollowUntilStopped?"
    },
    "AuroraDbInstanceNotEligibleForStopping?": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% $contains($states.input.Cause, 'aurora') and $contains($states.input.Cause, 'not eligible for stopping') %}",
          "Comment": "Aurora: stop cluster, not instances. This InvalidParameterCombination occurs only in test mode. RDS-EVENT-0088 database instance non-forced start is indistinguishable for RDS (accepted) and Aurora (ignored in favor of RDS-EVENT-0151 for cluster).",
          "Output": "{% $merge([\n  $states.input,\n  {'Info': 'StopAuroraClusterNotInstances'}\n]) %}",
          "Next": "Succeed"
        }
      ],
      "Default": "Fail"
    },
    "DescribeDBInstances": {
      "Type": "Task",
      "Resource": "arn:aws:states:::aws-sdk:rds:describeDBInstances",
      "Arguments": {
        "DbInstanceIdentifier": "{% $states.input.SourceIdentifier %}"
      },
      "TimeoutSeconds": "{% $Constant.StepFnTaskTimeoutSeconds %}",
      "Catch": [
        {
          "ErrorEquals": [
            "States.ALL"
          ],
          "Output": "{% $merge([\n  $states.input,\n{  'Error': 'DescribeDBInstances|' & $states.errorOutput.Error, 'Cause': $string($states.errorOutput.Cause)}\n]) %}",
          "Next": "Wait"
        }
      ],
      "Output": "{% (\n  $DbInstanceStatus := $states.result.DbInstances[0].DbInstanceStatus;\n  $merge([\n    $states.input,\n    $DbInstanceStatus\n    ?\n    {'DbStatus': $lowercase($DbInstanceStatus)}\n    :\n    {'DbStatus': '', 'Error': 'DescribeDBInstances|CannotParseResult', 'Cause': $string($states.result)}\n  ])\n) %}",
      "Next": "DbStatus"
    },
    "DbStatus": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% $states.input.DbStatus in ['inaccessible-encryption-credentials', 'cloning-failed', 'migration-failed', 'preparing-data-migration', 'failed', 'incompatible-restore', 'insufficient-capacity', 'restore-error', 'storage-full'] %}",
          "Output": "{% $merge([\n  $states.input,\n  {'Error': 'CannotContinueInDbStatus'}\n]) %}",
          "Next": "Fail"
        },
        {
          "Condition": "{% (('stopping' = $states.input.DbStatus) and $Constant.DoNotFollowUntilStopped) or ($states.input.DbStatus in ['stopped', 'deleting', 'deleted']) %}",
          "Next": "Succeed"
        }
      ],
      "Default": "Wait"
    },
    "FollowUntilStopped?": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% $Constant.DoNotFollowUntilStopped %}",
          "Next": "Succeed"
        }
      ],
      "Default": "Wait"
    },
    "Wait": {
      "Type": "Wait",
      "Seconds": "{% $Constant.StepFnWaitSeconds %}",
      "Next": "IfEventNotExpiredChooseDbClusterOrInstance"
    },
    "Fail": {
      "Type": "Fail"
    },
    "Succeed": {
      "Type": "Succeed",
      "Output": "{% \n  $states.input ~> | $ | {}, ['Error', 'Cause', 'DbStatus'] |\n  /* Delete any past error, and possibly-stale status; https://docs.jsonata.org/other-operators#-------transform */\n %}"
    }
  }
}
